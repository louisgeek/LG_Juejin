# Java 内存区域
- 线程私有的内存区域：虚拟机栈、本地方法栈和程序计数器
- 线程共享的内存区域：堆和元空间（​方法区）

## Virtual Machine Stack 虚拟机栈
- 虚拟机栈用于存储方法调用的 Stack Frame 栈帧（每个方法在执行时会创建一个栈帧），栈帧包括局部变量（基本数据类型的局部变量值、引用数据类型对象的引用）、操作数栈、动态链接和方法返回地址（方法出口）等
- 自动管理：由编译器自动分配和回收内存（在编译时确定大小直接分配内存）
- 栈分配速度快，不过容量有限，StackOverflowError 栈溢出风险较高
- 常见错误：StackOverflowError：调用栈过深（如无限递归），OutOfMemoryError：栈帧过多导致栈空间不足（局部变量过多）

## Native Method Stack 本地方法栈
- 本地方法栈和虚拟机栈类似，只不过是虚拟机栈为执行 Java 方法服务，而本地方法栈为使用 Native 本地方法（比如用 C/C++ 代码实现的方法）服务
- 常见错误：虚拟机栈一样也会抛出 StackOverflowError 和 OutOfMemoryError 异常

## Program Counter Register 程序计数器
- 程序计数器是一块较小的内存空间，用来记录当前线程所执行的字节码指令的行号指示器（保存当前程序的执行位置）
- 是唯一不会出现 OutOfMemoryError 的区域

## Heap 堆
- 也称为 GC 堆，用于存储局部变量中的对象实例值（包括数组）、成员变量（全局变量）中的实例变量、成员变量（全局变量）中的类变量（静态变量）（jdk 8 及以后）和字符串常量池（jdk 8 及以后）等，是 JVM 中最大的内存区域
- 需 GC 管理：通过 new 关键字或反射分配内存创建对象（在运行时动态分配内存），依赖 Garbage Collector 垃圾回收器自动管理回收不再使用的内存
- 分代垃圾回收：分为 Young Generation 新生代和 Old Generation 老年代，新生代又进一步分为 Eden 伊甸园区和两个 Survivor 幸存者区，即 S0（From Survivor）和 S1（To Survivor），为了提高垃圾回收的效率，优化内存管理，避免频繁的全堆回收
- 堆分配速度相对较慢，堆的大小通常较大，适合存储对象、大型数据结构，堆内存不足时会抛出 OutOfMemoryError
- 常见错误：OutOfMemoryError: Java heap space（堆内存不足：内存泄漏或对象过多） 

## Metaspace 元空间（Method Area ​方法区）
- 元空间（Method Area ​方法区，jdk 8 以前方法区被称为永久代，jdk 8 及以后，方法区被称为元空间，使用本地内存，减少 OOM 风险）用于存储类的元数据信息（类名、父类、接口、字段、方法和构造器信息等）、运行时常量池和即时编译器编译后的代码等数据
- 需 GC 管理：类卸载时回收内存
- 常见错误：OutOfMemoryError: Metaspace（元空间容量不足：加载过多类或反射动态生成过多类）

```java
Object obj = new Object();
//obj 进栈
//new Object() 进堆
//Object 类加载字节码文件，编译的 Object 类进方法区
//于是形成了栈指向堆、堆指向方法区（Class 元数据）
```

## 总结
- 虚拟机栈：存储方法调用栈帧（包括局部变量等数据），支持 Java 方法的调用执行
- 本地方法栈：支持 Native 本地方法的调用执行
- 程序计数器：支持字节码指令的执行
- 堆：存储引用类型对象实例等数据
- 元空间（​方法区）：存储类元数据信息等数据
- 局部变量：基本数据类型存在栈区中，引用数据类型对象的本身是存在堆区中，而对象的引用则是存在栈区中的
- 成员变量（全局变量）的实例变量：存在堆区中（基本数据类型和引用数据类型都存储在这个对象中，然后作为一个整体存储在堆内存中）
- 成员变量（全局变量）的类变量（静态变量）：在 jdk 8 以前是存在方法区中的，而在 jdk 8 及之后则存在堆中的


