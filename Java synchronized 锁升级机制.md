# Java synchronized 锁升级机制
- Java 通过引入锁升级机制来优化 synchronized 关键字对应锁的性能，允许锁根据线程竞争程度动态调整状态，从而在不同场景下提供最佳的并发性能，状态从低到高依次为：无锁（未锁定）、偏向锁、轻量级锁和重量级锁
- 锁状态升级的核心目标是平衡线程安全与性能，通过在不同竞争场景下使用不同级别的锁，减少获取和释放锁的开销

```java
//锁状态随着竞争激烈程度逐步升级，不可降级
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
```

## Unlocked 无锁
- 单线程或无竞争场景（比如原子变量 AtomicInteger 直接通过 compareAndSet 方法尝试获取锁），此时 synchronized 实际退化为无锁（JVM 优化）

## Biased Lock 偏向锁
- 当一个线程第一次获取锁时，会通过 CAS 操作将线程 ID 写入 Object Header 对象头结构中，后续同一线程再次获取锁时仅需比对线程 ID，无需 CAS 操作，避免 CAS 开销
- 锁会 “偏向” 第一个获取它的线程，后续该线程再次进入时无需竞争，直接使用（零成本获取锁）
- 为单线程访问优化，减少同一线程反复获取锁的开销
- 当其他线程尝试竞争时，会撤销偏向锁并升级为轻量级锁

## Lightweight Lock 轻量级锁
- 当偏向锁被其他线程竞争时，升级为轻量级锁，通过 CAS 自旋（循环检查锁状态，直到锁释放）尝试获取锁，实现非阻塞竞争，避免直接进行线程阻塞
- 轻量级锁的获取过程不需要调用操作系统的互斥量（Mutex），这使得它的性能开销比重量级锁小很多
- 适合短时竞争（低竞争）、同步块执行速度快的场景
- 当自旋次数超过阈值（默认 10 次）仍未获取锁或竞争激烈时，升级为重量级锁

## Heavyweight Lock 重量级锁
- 轻量级锁自旋失败或竞争激烈，升级为重量级锁，依赖操作系统互斥量（Mutex）实现，会阻塞其他线程，开销最大
- 适合长时竞争（高竞争）、同步块执行时间较长（复杂同步逻辑）的场景

## 总结
- 偏向锁被其他线程竞争时升级为轻量级锁，轻量级锁自旋失败升级为重量级锁
