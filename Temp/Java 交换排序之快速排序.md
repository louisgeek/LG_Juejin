# Java 排序算法之快速排序
- 快速排序是一种高效快速的交换排序算法，重复地遍历要排序的数组，一次比较相邻的两个元素，通过比较两个元素并交换位置，如果顺序错误（不符合预期顺序）就把他们交换过来，将较大（或较小）的元素逐渐 “冒泡” 到数组末尾，直到没有再需要交换的元素为止
- 冒泡排序属于比较类排序
- 冒泡排序易于理解和实现，但效率较低
- 时间复杂度：平均 O(n^2) 最好 O(n) 最坏 O(n^2)
- 空间复杂度：
- 稳定性：

Divide and Conquer
采用分治法策略来把一个序列分为较小和较大的两个子序列，然后递归地排序两个子序列
采用分治法的策略来把一个序列分为较小和较大的两个子序列，然后递归地排序这两个子序列
基于分治思想
从数组中选取一个元素作为基准（Pivot），一般选第一个/最后一个元素
将数组分为两部分，左边元素≤基准值，右边元素≥基准值
递归处理：对左右子数组重复上述过程，直到数组不可再分


```java
public static void main(String[] args) {
    int[] arr = {3, 5, 1, 7, 6, 2, 4};
    //外层循环遍历的次数控制排序的轮数，表示需要进行多少轮比较，每经过一轮排序最大的元素会逐渐 “冒泡” 到数组的末尾
    for (int i = 0; i < arr.length - 1; i++) {
        //内层循环进行相邻元素的比较和交换，每次循环结束后都会把未排序部分的最大元素移动到它的最终位置，后续的比较就不需要再包括这个元素，所以内层循环的比较范围会逐渐减小
        for (int j = 0; j < arr.length - 1 - i; j++) {
            //利用 - i 进行递减
            if (arr[j] > arr[j + 1]) { //升序
                //如果前面的元素比后面的元素大，则交换
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    //
    System.out.println("排序后的数组：");
    for (int num : arr) {
        System.out.print(num + " ");
    }
}
//---------------------------------
排序后的数组：
1 2 3 4 5 6 7 
```